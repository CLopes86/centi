# AI Coding Instructions - Centi Finance App

## Project Overview
**Centi** is an AI-powered personal finance tracker built with Flutter following **Clean Architecture**. It's a Portuguese app currently in development (Splash, Login, Register screens complete; Dashboard in progress).

**Tech Stack:** Flutter 3.x + Dart 3.x | Riverpod 3.x | Firebase Auth + Firestore | Clean Architecture

---

## Architecture: Three-Layer Separation

Every feature follows this rigid structure:

```
features/<feature_name>/
â”œâ”€â”€ domain/          # Business logic, framework-agnostic
â”‚   â”œâ”€â”€ entities/    # Core domain models (e.g., User)
â”‚   â”œâ”€â”€ repositories/ # Abstract interfaces (e.g., AuthRepository)
â”‚   â””â”€â”€ usecases/    # Business operations (e.g., LoginUser, RegisterUser)
â”œâ”€â”€ data/            # Data implementation layer
â”‚   â”œâ”€â”€ datasources/ # External APIs (Firebase)
â”‚   â”œâ”€â”€ models/      # Data models with conversions
â”‚   â””â”€â”€ repositories/ # Implements domain interfaces
â””â”€â”€ presentation/    # UI & state management
    â”œâ”€â”€ providers/   # Riverpod dependency injection
    â”œâ”€â”€ controllers/ # AsyncNotifier state managers
    â””â”€â”€ screens/     # UI widgets
```

**Critical Rule:** Domain layer imports NOTHING from data or presentation. Data layer doesn't import presentation.

---

## Key Patterns & Workflows

### 1. **Use Cases Pattern (Domain Layer)**
Every business operation is a use case class:
```dart
class LoginUser {
  final AuthRepository repository;
  LoginUser(this.repository);
  
  Future<User> call({required String email, required String password}) async {
    return await repository.login(email: email, password: password);
  }
}
```
- Single responsibility: one operation per class
- Call method is standard convention
- Receives dependencies in constructor

### 2. **Riverpod Dependency Injection (Providers)**
All dependencies are managed via `@riverpod` annotated functions in `auth_providers.dart`:
```dart
@riverpod
LoginUser loginUser(Ref ref) {
  final repository = ref.watch(authRepositoryProvider);
  return LoginUser(repository);
}
```
- Use `ref.watch()` to depend on other providers (creates dependency chain)
- Use `@riverpod` on functions, not classes (unless using AsyncNotifier)
- Generated file: `auth_providers.g.dart` (auto-generated by `build_runner`)

### 3. **State Management: AsyncNotifier**
Controllers extend `AsyncNotifier<T>` for async state:
```dart
@riverpod
class AuthController extends _$AuthController {
  @override
  Future<User?> build() async {
    final getCurrentUser = ref.read(getCurrentUserProvider);
    return await getCurrentUser.call();
  }
  
  Future<void> login(String email, String password) async {
    state = const AsyncValue.loading();
    try {
      final loginUseCase = ref.read(loginUserProvider);
      final user = await loginUseCase.call(email: email, password: password);
      state = AsyncValue.data(user);
    } catch (e, st) {
      state = AsyncValue.error(e, st);
    }
  }
}
```
- `build()` initializes state
- Use `ref.read()` for one-time access, `ref.watch()` for reactive updates
- Manually manage `AsyncValue.loading/data/error` states

### 4. **Firebase Integration (Data Layer)**
`AuthRemoteDataSource` wraps Firebase Auth calls:
```dart
class AuthRemoteDataSource {
  final FirebaseAuth firebaseAuth;
  
  AuthRemoteDataSource(this.firebaseAuth);
  
  Future<UserCredential> signIn({required String email, required String password}) async {
    return await firebaseAuth.signInWithEmailAndPassword(email: email, password: password);
  }
}
```
- Never expose Firebase types to domain layer
- Repository layer converts Firebase objects to domain entities

### 5. **Entity Conversion Pattern**
Models extend entities and provide conversion methods:
```dart
class UserModel extends User {
  UserModel({required String id, required String email, String? displayName})
    : super(id: id, email: email, displayName: displayName);
  
  factory UserModel.fromFirebase(firebase_auth.User firebaseUser) {
    return UserModel(
      id: firebaseUser.uid,
      email: firebaseUser.email ?? '',
      displayName: firebaseUser.displayName,
    );
  }
}
```
- Always extend domain entity
- Use factory constructors for conversions
- Handle Firebase nullability explicitly

---

## Development Workflows

### Running Tests
```bash
dart test                              # All tests
dart test test/auth_remote_datasource_test.dart  # Specific test file
```
- Mocking uses Mockito: `@GenerateMocks([FirebaseAuth])` annotations
- Generate mocks: `build_runner build`

### Code Generation
```bash
flutter pub run build_runner build     # Generate providers, controllers, mocks
flutter pub run build_runner watch     # Watch mode (auto-rebuild)
```
- Required after creating new `@riverpod` functions or `@GenerateMocks` annotations
- Check logs for errors in generated files

### Building App
```bash
flutter pub get                        # Install dependencies
flutter run                            # Debug mode (Android/iOS)
flutter build apk                      # Production Android
```

---

## Project-Specific Conventions

### Naming
- **Files:** snake_case (e.g., `auth_remote_datasource.dart`)
- **Classes:** PascalCase with clear suffix (e.g., `AuthRepositoryImpl`, `UserModel`)
- **Riverpod providers:** Lowercase + "Provider" suffix (auto-generated from function name)

### Documentation
- Domain entities have constructor doc comments explaining validation
- Use Cases include single-line doc explaining purpose
- Controllers have `// OBJETIVO:` comment block (Portuguese convention used in codebase)

### Error Handling
- Domain layer throws `ArgumentError` for validation (e.g., invalid email)
- Data layer doesn't catch Firebase exceptions (let them propagate)
- Presentation layer catches all errors and sets `AsyncValue.error()`

### Portuguese Naming
- Some comments/variable names are in Portuguese (e.g., `utilizador` = user)
- Keep Portuguese in comments but use English for code identifiers

---

## Typical Workflow: Adding a New Feature

1. **Domain layer**: Create entity, repository interface, use cases
2. **Data layer**: Implement repository, datasource, models
3. **Presentation layer**: Create controller (AsyncNotifier), add providers, build UI
4. **Dependency injection**: Wire up in `*_providers.dart` file
5. **Testing**: Write unit tests for datasource and use cases
6. **Run build_runner** to generate code

---

## Critical Files Reference

- **App Entry:** [lib/main.dart](lib/main.dart) - Firebase init, Riverpod ProviderScope
- **Theme:** [lib/core/theme/app_theme.dart](lib/core/theme/app_theme.dart) - Material 3, colors (Indigo #6366F1)
- **Auth Domain:** [lib/features/auth/domain](lib/features/auth/domain) - Pure business logic
- **Providers:** [lib/features/auth/presentation/providers/auth_providers.dart](lib/features/auth/presentation/providers/auth_providers.dart) - Dependency graph
- **Controller:** [lib/features/auth/presentation/controllers/auth_controller.dart](lib/features/auth/presentation/controllers/auth_controller.dart) - Riverpod AsyncNotifier
- **Tests:** [test/auth_remote_datasource_test.dart](test/auth_remote_datasource_test.dart) - Mockito pattern example

---

## Common Pitfalls

- âŒ Importing presentation in domain layer
- âŒ Forgetting to run `build_runner` after new `@riverpod` functions
- âŒ Using `ref.watch()` in `build()` for initialization (causes infinite loops)
- âŒ Catching Firebase exceptions in domain layer
- âŒ Forgetting `ProviderScope` wrapper in main.dart for Riverpod

---

## Roadmap de Desenvolvimento

### Estado Atual (~25-30% Completo)

| Componente | Estado | Progresso |
|-----------|--------|-----------|
| Domain Layer | âœ… Completa | 100% |
| Data Layer | âœ… Completa | 100% |
| Presentation - Backend | âœ… Completa | 100% |
| Presentation - UI | ğŸš§ Em Progresso | 5% |
| EcrÃ£s de AutenticaÃ§Ã£o | ğŸš€ Por Iniciar | 0% |
| Dashboard | ğŸš€ Por Iniciar | 0% |
| TransaÃ§Ãµes | ğŸš€ Por Iniciar | 0% |
| Categorias | ğŸš€ Por Iniciar | 0% |
| GrÃ¡ficos & AnÃ¡lises | ğŸš€ Por Iniciar | 0% |
| Sistema de OrÃ§amentos | ğŸš€ Por Iniciar | 0% |

### Sprint 1: AutenticaÃ§Ã£o (1-2 semanas)
- [x] Domain Layer (entities, repositories, use cases)
- [x] Data Layer (datasources, models, repository implementation)
- [x] Presentation Backend (providers, controllers)
- [ ] Login Screen (UI completa + validaÃ§Ã£o)
- [ ] Register Screen (UI completa + validaÃ§Ã£o)
- [ ] Testes unitÃ¡rios

### Sprint 2: Funcionalidades Core (2-3 semanas)
- [ ] Dashboard com visÃ£o geral financeira
- [ ] CRUD de TransaÃ§Ãµes (adicionar, editar, eliminar, listar)
- [ ] Sistema de Categorias
- [ ] GrÃ¡ficos bÃ¡sicos de despesas

### Sprint 3: Polimento & Funcionalidades AvanÃ§adas (2-3 semanas)
- [ ] GestÃ£o de OrÃ§amentos com alertas
- [ ] AnÃ¡lises avanÃ§adas e relatÃ³rios
- [ ] Dark Mode
- [ ] Testes completos (unit + widget)
- [ ] OtimizaÃ§Ã£o de performance

### Diferenciais (MVP Portugal)
- ğŸ‡µğŸ‡¹ IRS Refund Gamification - Live progress bar for tax benefits (15% VAT)
- ğŸ’³ MB WAY Smart Decoder - Aliases for phone numbers
- ğŸ½ï¸ Meal Card Tracker - Separated balance tracking
- ğŸ“ˆ Savings Certificates - Auto-calculation for interest

Quando adicionar estas features, siga o exato padrÃ£o de trÃªs camadas estabelecido na feature Auth.
